/* Filename : SynchronousDualQueue.cvl
   Author   : Stephen F. Siegel
   Created  :
   Modified : 2024-12-15

 */
#include "AtomicInteger.h"
#include "AtomicReference.cvh"
#include "Queue.h"
#include "tid.h"
#include "types.h"
#include <stdbool.h>
#include <stdlib.h>

static int nnonterm; // number of non-terminated threads
static int nin; // number of threads in a waiting region
static bool deadlock = false;
// flag i set to true if all threads are waiting and the
// condition on which thread i is waiting is false
static bool * flag;

void Queue_initialize(int nthread) {
  nnonterm = nthread;
  nin = 0;
  flag = malloc(nthread*sizeof(bool));
  for (int i=0; i<nthread; i++) flag[i] = false;
}

void Queue_finalize() {
  free(flag);
}

void Queue_terminate(int tid) {
  nnonterm--;
  //$print("Thread ", tid, " terminating.  nnonterm=", nnonterm, "\n");
}

bool Queue_stuck() {
  return deadlock;
}

typedef enum NodeType {ITEM, RESERVATION} NodeType;

typedef struct Node {
  NodeType type;
  AtomicInteger item;
  AtomicReference next;
} * Node;

static Node Node_create(T myItem, NodeType myType) {
  Node this = malloc(sizeof(struct Node));
  this->item = AtomicInteger_create(myItem);
  this->next = AtomicReference_create(NULL);
  this->type = myType;
  return this;
}

// not in original code...
static void Node_destroy(Node this) {
  AtomicReference_destroy(this->next);
  AtomicInteger_destroy(this->item);
  free(this);
}

struct Queue {
  AtomicReference head;
  AtomicReference tail;
};

Queue Queue_create() {
  Queue this = malloc(sizeof(struct Queue));
  Node sentinel = Node_create(-1, ITEM); // new Node(null, ITEM)
  this->head = AtomicReference_create(sentinel);
  this->tail = AtomicReference_create(sentinel);
  return this;
}

// not in original code...
void Queue_destroy(Queue queue) {
  // if node is not null, its next is not null
  Node curr = AtomicReference_get(queue->head);
  Node prev = NULL;
  while (curr != NULL) {
    prev = curr;
    curr = AtomicReference_get(curr->next);
    Node_destroy(prev);
  }
  AtomicReference_destroy(queue->head);
  AtomicReference_destroy(queue->tail);
  free(queue);
}

void Queue_enq(Queue this, T e) {
  $assert(!deadlock);
  int tid = tid_get(), nthread = tid_nthread();
  Node offer = Node_create(e, ITEM);
  while (true) {
    Node t = AtomicReference_get(this->tail),
      h = AtomicReference_get(this->head);
    if (h == t || t->type == ITEM) {
      Node n = AtomicReference_get(t->next);
      if (t == AtomicReference_get(this->tail)) {
        if (n != NULL) {
          AtomicReference_compare_and_set(this->tail, t, n);
        } else if (AtomicReference_compare_and_set(t->next, n, offer)) {
          AtomicReference_compare_and_set(this->tail, t, offer);
          // begin busy-wait
          nin++;
          while (AtomicInteger_get(offer->item) == e && !deadlock) {
            $atomic {
              if (nin == nnonterm && AtomicInteger_get(offer->item) == e) {
                flag[tid] = true;
                int sum = 0;
                for (int i=0; i<nthread; i++) sum += flag[i];
                if (sum == nin) deadlock = true;
              }
            }
          }
          if (deadlock) {
            $assert(AtomicInteger_get(offer->item) == e);
            return;
          }
          $atomic {
            nin--;
            for (int i=0; i<nthread; i++) flag[i] = false;
          }
          // end busy-wait
          h = AtomicReference_get(this->head);
          if (offer == AtomicReference_get(h->next))
            AtomicReference_compare_and_set(this->head, h, offer);
          return;
        }
      }
    } else {
      Node n = AtomicReference_get(h->next);
      if (t != AtomicReference_get(this->tail) ||
          h != AtomicReference_get(this->head) ||
          n == NULL) {
        continue;
      }
      bool success = AtomicInteger_compareAndSet(n->item, -1, e);
      AtomicReference_compare_and_set(this->head, h, n);
      if (success)
        return;
    }
  }      
}

T Queue_deq(Queue this) {
  $assert(!deadlock);
  int tid = tid_get(), nthread = tid_nthread();
  Node offer = Node_create(-1, RESERVATION);
  while (true) {
    Node t = AtomicReference_get(this->tail),
      h = AtomicReference_get(this->head);
    if (h == t || t->type == RESERVATION) {
      Node n = AtomicReference_get(t->next);
      if (t == AtomicReference_get(this->tail)) {
        if (n != NULL) {
          AtomicReference_compare_and_set(this->tail, t, n);
        } else if (AtomicReference_compare_and_set(t->next, n, offer)) {
          AtomicReference_compare_and_set(this->tail, t, offer);
          // begin busy-wait
          nin++;
          while (AtomicInteger_get(offer->item) == -1) {
            $atomic {
              if (nin == nnonterm && AtomicInteger_get(offer->item) == -1) {
                flag[tid] = true;
                int sum = 0;
                for (int i=0; i<nthread; i++) sum += flag[i];
                if (sum == nin) deadlock = true;
              }
            }
          }
          if (deadlock) {
            $assert(AtomicInteger_get(offer->item) == -1);
            $print("Returning[0]: -1\n");
            return -1;
          }
          $atomic {
            nin--;
            for (int i=0; i<nthread; i++) flag[i] = false;
          }
          // end busy-wait
          h = AtomicReference_get(this->head);
          if (offer == AtomicReference_get(h->next))
            AtomicReference_compare_and_set(this->head, h, offer);
          $print("Returning[1] ", AtomicInteger_get(offer->item), "\n");
          return AtomicInteger_get(offer->item);
        }
      }
    } else {
      Node n = AtomicReference_get(h->next);
      if (t != AtomicReference_get(this->tail) ||
          h != AtomicReference_get(this->head) ||
          n == NULL) {
        continue;
      }
      T item = AtomicInteger_get(n->item);
      bool success = AtomicInteger_compareAndSet(n->item, item, -1);
      AtomicReference_compare_and_set(this->head, h, n);
      if (success) {
        $print("Returning[2] ", item, "\n");
        return item;
      }
    }
  }
}

void Queue_print(Queue this) {
  Node prev = AtomicReference_get(this->head),
    curr = AtomicReference_get(prev->next);
  $print("{ ");
  while (curr != NULL) {
    int val = AtomicInteger_get(curr->item);
    $print(val);
    if (curr->type == RESERVATION)
      $print("[R] ");
    else
      $print(" ");
    prev = curr;
    curr = AtomicReference_get(curr->next);
  }
  $print("}");
}

#ifdef _SYNCHRONOUS_DUAL_QUEUE

void test1() {
  int N=2, nthread=2*N;
  Queue_initialize(nthread);
  Queue q = Queue_create();
  $parfor (int i: 0..nthread-1) {
    if (i%2 == 0) {
      Queue_enq(q, i);
      /*
      $atomic {
        $print("Thread ", i, " enqueued ", i, "\n");
        Queue_print(q);
        $print("\n");
      }
      */
    }
    else {
      int result = Queue_deq(q);
      /*
      $atomic {
        $print("Thread ", i, " dequeued ", result, "\n");
        Queue_print(q);
        $print("\n");
      }
      */
    }
  }
  $print("Done: ");
  Queue_print(q);
  $print("\n");
  $assert(!Queue_stuck());
  Queue_destroy(q);
  Queue_finalize();
}

void test2() {
  int nthread=2;
  Queue_initialize(nthread);
  Queue q = Queue_create();
  $parfor (int i: 0..nthread-1) {
    
    Queue_enq(q, i);
  }
  $print("Done: ");
  Queue_print(q);
  $print("\n");
  if (Queue_stuck()) $print("DEADLOCK!\n");
  else $assert(false);
  Queue_destroy(q);
  Queue_finalize();
}

void test3() {
  int nthread=3;
  tid_init(nthread);
  Queue_initialize(nthread);
  Queue q = Queue_create();
  $parfor (int i: 0..nthread-1) {
    tid_register(i);
    if (i==0)
      Queue_enq(q, i);
    else {
      int x = Queue_deq(q);
      $assert(Queue_stuck() || x >= 0);
    }
    tid_unregister();
  }
  Queue_destroy(q);
  Queue_finalize();
}

int main() {
  /*
  $print("Test 1 ... \n");
  test1();
  $print("Test 2 ... \n");
  test2();
  */
  test3();
}
#endif
