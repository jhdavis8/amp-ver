/* Bounded partial queue implementation
 * using two locks.
 * Sep-8-2023
 * Josh Davis
 * VSL Lab; Dept. CIS; UDel
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include "queue.cvh"
#include "reentrant_lock.cvh"

#define CAPACITY 8

typedef struct _node
{
  int value;
  struct _node* next;
} Node;

Node* node_create(int value) {
  Node* new_node = (Node*) malloc(sizeof(Node));
  new_node->value = value;
  new_node->next = NULL;
  return new_node;
}

typedef struct _queue
{
  Lock* enq_lock;
  Lock* deq_lock;
  Node* head;
  Node* tail;
  int size;
} Queue;

Queue* queue_create() {
  Queue* new_queue = (Queue*) malloc(sizeof(Queue));
  new_queue->head = node_create(-1);
  new_queue->tail = new_queue->head;
  new_queue->enq_lock = lock_create();
  new_queue->deq_lock = lock_create();
  return new_queue;
}

bool enq(Queue* queue, int value) {
  lock_acquire(queue->enq_lock);
  Node* e = node_create(value);
  queue->tail->next = e;
  queue->tail = e;
  queue->size++;
  lock_release(queue->enq_lock);
  return true;
}

int deq(Queue* queue) {
  int result;
  lock_acquire(queue->deq_lock);
  if (queue->head->next == NULL) {
    lock_release(queue->deq_lock);
    return -1;
  }
  result = queue->head->next->value;
  queue->head = queue->head->next;
  queue->size--;
  lock_release(queue->deq_lock);
  return result;
}

bool queue_contains(Queue* queue, int value) {
  Node* curr = queue->head;
  while (curr) {
    if (curr->value == value) return true;
    curr = curr->next;
  }
  return false;
}

int queue_index(Queue* queue, int index) {
  if (index < queue->size) return -1;
  int i = -1; // count from first after sentinel
  Node* curr = queue->head;
  while (curr) {
    if (index == i) return curr->value;
    curr = curr->next;
    index++;
  }
  return -1;
}

bool queue_destroy(Queue* queue) {
  Node* curr = queue->head;
  while (curr) {
    Node* temp = curr;
    curr = curr->next;
    free(temp);
  }
  free(queue->enq_lock);
  free(queue->deq_lock);
  free(queue);
  return true;
}

void queue_print(Queue* queue) {
  Node* curr = queue->head;
  while (curr) {
    if (curr->value >= 0) printf("%d ", curr->value);
    curr = curr->next;
  }
  printf("\n");
}

int queue_size(Queue* queue) {
  return queue->size;
}
