/* CIVL model of BucketList class from "The Art of Multiprocessor
 * Programming" 2nd ed, by Herlihy, Luchangco, Shavit, and Spear,
 * Sec. 13.3.2 "The BucketList class", and companion code
 * ch13/src/hash/BucketList.java.
 *
 * Description here
 *
 * Created : 2024-Dec-12
 * Authors : Josh Davis and Stephen F. Siegel
 * Verified Software Laboratory, Dept. Computer & Info. Sciences,
 * University of Delaware.
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "Set.h"
#include "hash.cvh"
#include "AtomicMarkableReference.cvh"
#include "types.h"

const int WORD_SIZE = 24;
const int LO_MASK = 0x00000001;
const int HI_MASK = 0x00800000;
const int MASK = 0x00FFFFFF;

struct Node {
  int key;
  T value;
  AtomicMarkableReference next;
};

Node Node_create(int key, T object) {
  Node this = malloc(sizeof(struct Node));
  this->key = key;
  this->value = object;
  this->next = AtomicMarkableReference_create(NULL, false);
  return this;
}

Node Node_create_sentinel(int key) {
  return Node_create(key, 0);
}

void Node_destroy(Node n) {
  AtomicMarkableReference_destroy(n->next);
  free(n);
}

Node Node_getNext(Node this) {
  bool cMarked[1] = {false};
  bool sMarked[1] = {false};
  Node entry = AtomicMarkableReference_get(this->next, cMarked);
  while (cMarked[0]) {
    Node succ = AtomicMarkableReference_get(entry->next, sMarked);
    AtomicMarkableReference_compareAndSet(this->next, entry, succ, true, sMarked[0]);
    entry = AtomicMarkableReference_get(this->next, cMarked);
  }
  return entry;
}

struct Window {
  Node pred;
  Node curr;
};

Window Window_create(Node pred, Node curr) {
  Window this = malloc(sizeof(struct Window));
  this->pred = pred;
  this->curr = curr;
  return this;
}

void Window_destroy(Window w) {
  free(w);
}

Window Window_find(Node head, int key) {
  Node pred = head;
  Node curr = Node_getNext(head);
  while (curr->key < key) {
    pred = curr;
    curr = Node_getNext(pred);
  }
  return Window_create(pred, curr);
}

struct BucketList {
  Node head;
};

BucketList BucketList_create() {
  BucketList this = malloc(sizeof(struct BucketList));
  this->head = Node_create_sentinel(0);
  this->head->next = AtomicMarkableReference_create(Node_create_sentinel(INT_MAX), false);
  return this;
}

void BucketList_destroy(BucketList this) { // this needs work!
  Node_destroy(this->head);
  free(this);
}

BucketList BucketList_BucketList(BucketList this, Node e) {
  this->head = e;
  return this;
}

// forward declarations for bit manipulation functions
int BucketList_reverse(int key);
int BucketList_makeRegularKey(T x);
int BucketList_makeSentinelKey(int key);

bool BucketList_add(BucketList this, T x) {
  int key = BucketList_makeRegularKey(x);
  bool splice;
  while (true) {
    // find predecessor and current entries
    Window window = Window_find(this->head, key);
    Node pred = window->pred;
    Node curr = window->curr;
    // is the key present?
    if (curr->key == key) {
      return false;
    } else {
      // splice in new entry
      Node entry = Node_create(key, x);
      entry->next = AtomicMarkableReference_set(entry->next, curr, false);
      splice = AtomicMarkableReference_compareAndSet(pred->next, curr, entry, false, false);
      if (splice)
        return true;
      else
        continue;
    }
  }
}

bool BucketList_remove(BucketList this, T x) {
  int key = BucketList_makeRegularKey(x);
  bool snip;
  while (true) {
    // find predecessor and current entries
    Window window = Window_find(this->head, key);
    Node pred = window->pred;
    Node curr = window->curr;
    // is the key present?
    if (curr->key != key) {
      return false;
    } else {
      // snip out matching entry
      snip = AtomicMarkableReference_attemptMark(pred->next, curr, true);
      if (snip)
        return true;
      else
        continue;
    }
  }
}

bool BucketList_contains(BucketList this, T x) {
  int key = BucketList_makeRegularKey(x);
  Window window = Window_find(this->head, key);
  Node pred = window->pred;
  Node curr = window->curr;
  return (curr->key == key);
}

BucketList BucketList_getSentinel(int index) {
  int key = BucketList_makeSentinelKey(index);
  bool splice;
  while (true) {
    // find predecessor and current entries
    Window window = Window_find(this->head, key);
    Node pred = window->pred;
    Node curr = window->curr;
    // is the key present?
    if (curr->key == key) {
      return curr;
    } else {
      // splice in new entry
      Node entry = Node_create_sentinel(key);
      entry->next = AtomicMarkableReference_set(entry->next, curr, false);
      splice = AtomicMarkableReference_compareAndSet(pred->next, curr, entry, false, false);
      if (splice)
        return entry;
      else
        continue;
    }
  }
}

int BucketList_reverse(int key) {
  int loMask = LO_MASK;
  int hiMask = HI_MASK;
  int result = 0;
  for (int i = 0; i < WORD_SIZE; i++) {
    if ((key & loMask) != 0) { // bit set
      result |= hiMask;
    }
    loMask <<= 1;
    hiMask >>= 1;  // fill with 0 from left
  }
  return result;
}

int BucketList_makeRegularKey(T x) {
  int code = hash_code(x) & MASK; // take 3 lowest bytes
  return BucketList_reverse(code | HI_MASK);
}

int BucketList_makeSentinelKey(int key) {
  return BucketList_reverse(key & MASK);
}
