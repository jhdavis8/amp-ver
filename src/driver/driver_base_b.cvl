#pragma CIVL ACSL
#include "dlcatch.h"
#include "driver.h"
#include "perm.h"
#include "schedule.h"
#include "tid.h"
#include "types.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

// Global Vars...
schedule_t schedule; // the schedule
int nthread; // number of threads
#ifndef NLINEAR
static int time = 0;
static bool status = 0; // 0=last event was a start. 1=last event was a stop
#endif

/*@ depends_on \nothing; */
static $atomic_f int get_nsteps(int tid) {
  return schedule.nsteps[tid];
}

/*@ depends_on \nothing; */
static $atomic_f step_t get_step(int tid, int s) {
  return schedule.steps[tid][s];
}

// Sets result and stop time.
// Exit earlier linearizable => exit later linearizable
/*@ depends_on \nothing; */
static $atomic_f void set_result(int tid, int s, int result) {
#ifndef NLINEAR
  if (status == 0) status = 1;
  schedule.steps[tid][s].stop_time = time;
#endif
  schedule.steps[tid][s].result = result;
}

#ifndef NLINEAR
/*@ depends_on \access(&time); */
static $atomic_f void set_start_time(int tid, int s) {
  if (status == 1) {
    status = 0;
    time++;
  }
  schedule.steps[tid][s].start_time = time;
}
#endif

static void printMatchFail(void * collection, int stuckID) {
  printf("[FAIL]\t No matching sequentialized execution");
  if (stuckID >= 0)
    printf(" ending with thread %d blocked", stuckID);
  printf("found!\n");
  printf("Collection final state... ");
  collection_print(collection);
  printf("\n");
}

static void printOpInfo(int tid, int op, int val, int score, int result) {
  printf("  Thread %d: ", tid);
  printf((op==ADD?"ADD":(op==REMOVE?"REMOVE":"CONTAINS")));
  if (val >= 0) {
    printf("(%d", val);
    if (score >= 0) printf(",%d)", score);
    else printf(")");
  }
  printf(" -> ");
  if (result != UNDEF) printf("%d", result); else printf("STUCK");
  printf("\n");
}

static void printEquivSeqInfo(int nstep, int * perms, void * oracle,
                              int stuckID) {
  int nthread = schedule.nthread;
  int step_counters[nthread];
  for (int tid = 0; tid < nthread; tid++)
    step_counters[tid] = 0;
  printf("[PASS]\t Linearized execution:\n");
  for (int step_id = 0; step_id < nstep; step_id++) {
    int tid = perms[step_id];
    int step_local = step_counters[tid];
    step_t step = schedule.steps[tid][step_local];
    printOpInfo(tid, step.op, step.args[0], step.args[1], step.result);
    step_counters[tid]++;
  }
  if (stuckID >= 0) {
    int step_local = step_counters[stuckID];
    step_t step = schedule.steps[stuckID][step_local];
    printOpInfo(stuckID, step.op, step.args[0], step.args[1], step.result);
  }
  printf("Oracle final state....... ");
  oracle_print(oracle);
  printf("\n\n");
}

/* Determines whether the sequentialization of the schedule specified
 * by perm matches the results of the concurrent execution.  The
 * results of the concurrent execution are recorded in the schedule
 * (before this function is called).  This function works for both
 * normal executions (in which every thread completes all of its steps
 * and terminates normally) and stuck executions, which end in
 * deadlock.
 *
 * nstep: the total number of steps in the execution.  This is at most
 * schedule.nstep.  Note: nstep does not include preAdds.
 *
 * perm: array of length nstep. perm[i] is the ID of the thread that
 * executes step i in the linear sequence of steps.  Hence perm,
 * together with global variable schedule, specifies a single
 * sequentialization of the concurrent execution.
 *
 * oracle: the simple trusted sequential implementation of the data
 * structure.  The sequentialized execution will be executed on this
 * oracle.  Note that oracle may be nonempty when this function is
 * called due to preAdds.
 *
 * stuckID: for a normal execution, this is -1.  For a stuck
 * execution, this is the ID of the thread that got stuck in its last
 * step: it called, but never returned from, a method.  This last
 * incomplete step is the step just after the nstep steps of the
 * schedule have been executed.  For a sequential execution to match,
 * thread stuckID must have this next step disabled in the oracle.
 */
static bool permseq(int nstep, int * perm, void * oracle, int stuckID) {
  int nthread = schedule.nthread, step_counters[nthread];
  for (int tid = 0; tid < nthread; tid++)
    step_counters[tid] = 0;
  for (int step_seq = 0; step_seq < nstep; step_seq++) {
    int tid = perm[step_seq];
    int step_id = step_counters[tid];
    step_t step = schedule.steps[tid][step_id];
    $assert(step.result != UNDEF);
    int op = step.op, a0 = step.args[0], a1 = step.args[1];
    bool oracle_match = false;
    int result;
    if (op == ADD) {
      if (oracle_add_enabled(oracle, a0, a1))
        result = (int)oracle_add(oracle, a0, a1);
      else
        return false;
    } else if (op == REMOVE) {
      // for a priority queue, you want to specify the value to
      // remove, which is not the argument a0, but the result.
      if (oracle_remove_enabled(oracle, a0, step.result))
        result = (int)oracle_remove(oracle, a0, step.result);
      else
        return false;
    } else if (op == CONTAINS) {
      result = (int)oracle_contains(oracle, a0);
    } else {
      $assert(false);
    }
    step_counters[tid]++;
    oracle_match = result == step.result;
    if (!oracle_match) return false; 
  }
  if (stuckID >= 0) {
    // check that the thread stuckID is now blocked...
    int step_id = step_counters[stuckID];
    step_t step = schedule.steps[stuckID][step_id];
    $assert(step.result == UNDEF);
    int op = step.op, a0 = step.args[0], a1 = step.args[1];
    if (op == ADD)
      return !oracle_add_enabled(oracle, a0, a1);
    if (op == REMOVE)
      return !oracle_remove_enabled(oracle, a0, step.result);
    if (op == CONTAINS)
      return false; // oracle never blocks on contains
  }
  return true;
}

/* The code executed by one thread in the concurrent execution.  tid
 * is the thread's ID number; c is a pointer to the concurrent data
 * structure upon which it will act.  The thread will execute the
 * sequence of steps specified in the schedule for the given ID. */
static void thread(int tid, void * c) {
  tid_register(tid);
  int num_steps_local = get_nsteps(tid);
  for (int s = 0; s < num_steps_local; s++) {
    step_t step = get_step(tid, s);
    int op = step.op, a0 = step.args[0], a1 = step.args[1];
#ifndef NLINEAR
    set_start_time(tid, s);
#endif
    if (op == ADD) {
      step.result = (int)collection_add(c, a0, a1);
    } else if (op == REMOVE) {
      step.result = (int)collection_remove(c, a0);
      // TODO: clarify what should happen when remove fails
    } else if (op == CONTAINS) {
      step.result = (int)collection_contains(c, a0);
    } else {
      $assert(false);
    }
    if (dlcatch_isDeadlocked())
      break;
    set_result(tid, s, step.result);
  }
  dlcatch_terminate(tid);
  tid_unregister();
}

static _Bool match(void * collection, int nstep, int num_perms,
                   int ** perms, int stuckID) {
  void * oracle = NULL;
  int perm_id = 0;
  printf("numPerms=%d\n", num_perms);
  for (; perm_id < num_perms; perm_id++) {
    // check if this perm has been filtered out as non-linearizable
    // note: if nstep=1, the linearizability condition holds vacuously
    if (nstep > 1 && perms[perm_id][0] < 0) continue;
    oracle = oracle_create();
    for (int i=0; i<schedule.npreAdd; i++)
      oracle_add(oracle, schedule.preAdds[i].args[0],
                 schedule.preAdds[i].args[1]);
    if (permseq(nstep, perms[perm_id], oracle, stuckID))
      break; // match found
    oracle_destroy(oracle);
    oracle = NULL;
  }
  if (oracle) { // match found
    printEquivSeqInfo(nstep, perms[perm_id], oracle, stuckID);
    oracle_destroy(oracle);
    return $true;
  } else { // no match found
    printMatchFail(collection, stuckID);
    schedule_print(schedule);
    perm_print_all(num_perms, nstep, perms);
    printf("\n");
    return $false;
  }
}

static int ** compute_perms(int * counts) {
#ifdef NLINEAR
  return perm_compute(nthread, counts);
#else
  return perm_compute_linear(schedule, counts);
#endif
}

static void find_match_normal(void * collection) {
  int * counts = schedule.nsteps, nstep = schedule.nstep;
  int num_perms = perm_calc_num(nthread, counts);
  int ** perms = compute_perms(counts);
  $assert(match(collection, nstep, num_perms, perms, -1));
  for (int i = 0; i < num_perms; i++) free(perms[i]);
  free(perms);
}

static void find_match_stuck(void * collection) {
  int counts[nthread]; // number of completed steps in each thread
  int nstep = 0; // total number of completed steps (sum of counts[])
  for (int i=0; i<nthread; i++) {
    int j = 0, stop = schedule.nsteps[i];
    for (; j<stop && schedule.steps[i][j].result != UNDEF; j++) ;
    counts[i] = j;
    nstep += j;
  }
  int num_perms = perm_calc_num(nthread, counts);
  int ** perms = compute_perms(counts);
  for (int tid=0; tid<nthread; tid++) {
    if (counts[tid] != schedule.nsteps[tid])
      $assert(match(collection, nstep, num_perms, perms, tid));
  }
  for (int i = 0; i < num_perms; i++) free(perms[i]);
  free(perms);
}

int main() {
  schedule = make_schedule();
  schedule_print(schedule);
  nthread = schedule.nthread;
  tid_init(nthread);
  void * collection = collection_create();
  tid_register(0);
  for (int i=0; i<schedule.npreAdd; i++)
    collection_add(collection, schedule.preAdds[i].args[0],
                   schedule.preAdds[i].args[1]);
  tid_unregister();
  printf("Collection initial state. ");
  collection_print(collection);
  printf("\n");
  dlcatch_init(nthread);
  $parfor (int tid : 0 .. nthread-1) {
    thread(tid, collection);
  }
  _Bool deadlock = dlcatch_isDeadlocked();
  dlcatch_destroy();
  tid_destroy();
  schedule_print(schedule);
  printf("Collection final state... ");
  collection_print(collection);
  printf("\n");
  if (deadlock)
    find_match_stuck(collection);
  else 
    find_match_normal(collection);
  collection_destroy(collection);
  schedule_destroy(schedule);
}
