/* This driver implements a trusted oracle for bounded queues. It is a simple
 * sequential implementation and thus does not actually block. The
 * oracle_add_enabled and oracle_remove_enabled functions indicate whether the
 * add and remove operations would block or proceed in a blocking queue being
 * operated on by a single thread. Therefore, in the base driver, the user code
 * for this oracle must check whether add and remove are enabled before calling
 * the actual add or remove functions, respectively.
 *
 * Created  : 2024-Sept-23
 * Modified : 2024-Sept-23
 * Authors  : Josh Davis
 * Verified Software Laboratory, Dept. Computer & Info. Sciences,
 * University of Delaware.
 */

#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <seq.cvh>
#include "types.h"
#include "Queue.h"
#include "driver.h"

#ifndef INITIAL_CAPACITY
#define INITIAL_CAPACITY 2
#endif

typedef struct SimpleQueue {
  int data[];
  int capacity;
} * SimpleQueue;

void * collection_create() {
  return Queue_create();
}

void collection_destroy(void * c) {
  Queue_destroy(c);
}

bool collection_add(void * c, int a0, int a1) {
  Queue_enq(c, a0);
  return true;
}

bool collection_contains(void * c, int a) {
  $assert(false);
}

int collection_remove(void * c, int a) {
  return Queue_deq(c);
}

void collection_print(void * c) {
  Queue_print(c);
}

void * oracle_create() {
  SimpleQueue sq = malloc(sizeof(struct SimpleQueue));
  $seq_init(&sq->data, 0, NULL);
  int capacity = INITIAL_CAPACITY;
  return sq;
}

void oracle_destroy(void * o) {
  free(o);
}

// add is enabled iff the number of elements in the queue is less than the
// capacity
bool oracle_add_enabled(void * o, int a0, int a1) {
  SimpleQueue sq = (SimpleQueue)o;
  if ($seq_length(&sq->data) < sq->capacity) return true;
  return false;
}

// append a0 to end.  a1 ignored.
bool oracle_add(void * o, int a0, int a1) {
  $assert(oracle_add_enabled(o, a0, a1));
  SimpleQueue sq = (SimpleQueue)o;
  int n = $seq_length(&sq->data);
  $seq_insert(&sq->data, n, &a0, 1);
  return true;
}

bool oracle_contains(void * o, int a) {
  $assert(false);
}

// remove is enabled iff the queue is non-empty
bool oracle_remove_enabled(void * o, int a, int expect) {
  SimpleQueue sq = (SimpleQueue)o;
  if ($seq_length(&sq->data) == 0) return false;
  return true;
}

// remove from pos 0. a and expect are ignored
int oracle_remove(void * o, int a, int expect) {
  $assert(oracle_remove_enabled(o, a, expect));
  SimpleQueue sq = (SimpleQueue)o;
  int result;
  $seq_remove(&sq->data, 0, &result, 1);
  return result;
}

void oracle_print(void * o) {
  SimpleQueue sq = (SimpleQueue)o;
  int n = $seq_length(&sq->data);
  printf("{ ");
  for (int i=0; i<n; i++) {
    printf("%d ", sq->data[i]);
  }
  printf("}");
}
